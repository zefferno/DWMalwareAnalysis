using System;
using System.Collections.Generic;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Reflection;
using System.Resources;

namespace Malware_Unpacker
{
    class Program
    {
        #region From Trojan SRC
        public class SteganographyData
        {
            public Bitmap bitmap_0;
            public BitmapData bitmapData_0;
            public int int_0;
            public int int_1;
            public PixelFormat pixelFormat_0;

            public SteganographyData(Bitmap bitmap_1)
            {
                this.bitmap_0 = bitmap_1;
                this.int_0 = this.bitmap_0.Width;
                this.int_1 = this.bitmap_0.Height;
                this.pixelFormat_0 = PixelFormat.Format24bppRgb;

                this.bitmapData_0 = bitmap_0.LockBits(new Rectangle(0, 0, int_0, int_1), ImageLockMode.ReadWrite, pixelFormat_0);
            }
        }

        static SteganographyData loadBitmap(string string_0)
        {
            return new SteganographyData(new Bitmap(System.Drawing.Image.FromFile(string_0, true)));
        }

        static unsafe Color getColor(SteganographyData class2_0, int int_0, int int_1)
        {
            byte* numPtrExt = (byte*)(class2_0.bitmapData_0.Scan0.ToPointer());
            byte* numPtr = (byte*)(numPtrExt + ((int_1 * class2_0.bitmapData_0.Stride) + (int_0 * 3)));
            byte alpha = numPtr[3];
            byte red = numPtr[2];
            byte green = numPtr[1];
            byte blue = numPtr[0];
            return Color.FromArgb(alpha, red, green, blue);
        }

        static byte[] steganography(SteganographyData class2_0)
        {
            List<byte> list = new List<byte>();
            for (int i = 0; i < class2_0.bitmap_0.Width; i++)
            {
                Color color = getColor(class2_0, i, 0);
                byte r = color.R;
                byte g = color.G;
                byte b = color.B;
                list.Add(r);
                list.Add(g);
                list.Add(b);
            }
            return Decompress(list.ToArray());
        }

        static int getIndex(byte[] byte_0)
        {
            if ((byte_0[0] & 2) != 2)
            {
                return 3;
            }
            return 9;
        }

        static int getLength(byte[] byte_0)
        {
            if (getIndex(byte_0) == 9)
            {
                return (((byte_0[5] | (byte_0[6] << 8)) | (byte_0[7] << 0x10)) | (byte_0[8] << 0x18));
            }
            return byte_0[2];
        }

        static byte[] Decompress(byte[] byte_0)
        {
            int length = getLength(byte_0);
            int index = getIndex(byte_0);
            int num4 = 0;
            uint num5 = 1;
            byte[] buffer = new byte[length];
            int[] numArray = new int[0x1000];
            byte[] buffer2 = new byte[0x1000];
            int num6 = ((length - 6) - 4) - 1;
            int num7 = -1;
            uint num9 = 0;
            int num = (byte_0[0] >> 2) & 3;
            if ((num != 1) && (num != 3))
            {
                throw new ArgumentException("C# version only supports level 1 and 3");
            }
            if ((byte_0[0] & 1) != 1)
            {
                byte[] destinationArray = new byte[length];
                Array.Copy(byte_0, getIndex(byte_0), destinationArray, 0, length);
                return destinationArray;
            }
            while (true)
            {
                int num8;
                if (num5 == 1)
                {
                    num5 = (uint)(((byte_0[index] | (byte_0[index + 1] << 8)) | (byte_0[index + 2] << 0x10)) | (byte_0[index + 3] << 0x18));
                    index += 4;
                    if (num4 <= num6)
                    {
                        if (num == 1)
                        {
                            num9 = (uint)((byte_0[index] | (byte_0[index + 1] << 8)) | (byte_0[index + 2] << 0x10));
                        }
                        else
                        {
                            num9 = (uint)(((byte_0[index] | (byte_0[index + 1] << 8)) | (byte_0[index + 2] << 0x10)) | (byte_0[index + 3] << 0x18));
                        }
                    }
                }
                if ((num5 & 1) == 1)
                {
                    uint num10;
                    uint num11;
                    num5 = num5 >> 1;
                    if (num == 1)
                    {
                        num8 = ((int)(num9 >> 4)) & 0xfff;
                        num11 = (uint)numArray[num8];
                        if ((num9 & 15) != 0)
                        {
                            num10 = (num9 & 15) + 2;
                            index += 2;
                        }
                        else
                        {
                            num10 = byte_0[index + 2];
                            index += 3;
                        }
                    }
                    else
                    {
                        uint num12;
                        if ((num9 & 3) == 0)
                        {
                            num12 = (uint)((num9 & 0xff) >> 2);
                            num10 = 3;
                            index++;
                        }
                        else if ((num9 & 2) == 0)
                        {
                            num12 = (uint)((num9 & 0xffff) >> 2);
                            num10 = 3;
                            index += 2;
                        }
                        else if ((num9 & 1) == 0)
                        {
                            num12 = (uint)((num9 & 0xffff) >> 6);
                            num10 = ((num9 >> 2) & 15) + 3;
                            index += 2;
                        }
                        else if ((num9 & 0x7f) != 3)
                        {
                            num12 = (num9 >> 7) & 0x1ffff;
                            num10 = ((num9 >> 2) & 0x1f) + 2;
                            index += 3;
                        }
                        else
                        {
                            num12 = num9 >> 15;
                            num10 = ((num9 >> 7) & 0xff) + 3;
                            index += 4;
                        }
                        num11 = ((uint)num4) - num12;
                    }
                    buffer[num4] = buffer[num11];
                    buffer[num4 + 1] = buffer[(int)((IntPtr)(num11 + 1))];
                    buffer[num4 + 2] = buffer[(int)((IntPtr)(num11 + 2))];
                    for (int i = 3; i < num10; i++)
                    {
                        buffer[num4 + i] = buffer[(int)((IntPtr)(num11 + i))];
                    }
                    num4 += (int)num10;
                    if (num == 1)
                    {
                        for (num9 = (uint)((buffer[num7 + 1] | (buffer[num7 + 2] << 8)) | (buffer[num7 + 3] << 0x10)); num7 < (num4 - num10); num9 = ((num9 >> 8) & 0xffff) | ((uint)(buffer[num7 + 3] << 0x10)))
                        {
                            num7++;
                            num8 = ((int)((num9 >> 12) ^ num9)) & 0xfff;
                            numArray[num8] = num7;
                            buffer2[num8] = 1;
                        }
                        num9 = (uint)((byte_0[index] | (byte_0[index + 1] << 8)) | (byte_0[index + 2] << 0x10));
                    }
                    else
                    {
                        num9 = (uint)(((byte_0[index] | (byte_0[index + 1] << 8)) | (byte_0[index + 2] << 0x10)) | (byte_0[index + 3] << 0x18));
                    }
                    num7 = num4 - 1;
                }
                else
                {
                    if (num4 > num6)
                    {
                        while (num4 <= (length - 1))
                        {
                            if (num5 == 1)
                            {
                                index += 4;
                                num5 = 0x80000000;
                            }
                            buffer[num4] = byte_0[index];
                            num4++;
                            index++;
                            num5 = num5 >> 1;
                        }
                        return buffer;
                    }
                    buffer[num4] = byte_0[index];
                    num4++;
                    index++;
                    num5 = num5 >> 1;
                    if (num == 1)
                    {
                        while (num7 < (num4 - 3))
                        {
                            num7++;
                            int num14 = (buffer[num7] | (buffer[num7 + 1] << 8)) | (buffer[num7 + 2] << 0x10);
                            num8 = ((num14 >> 12) ^ num14) & 0xfff;
                            numArray[num8] = num7;
                            buffer2[num8] = 1;
                        }
                        num9 = ((num9 >> 8) & 0xffff) | ((uint)(byte_0[index + 2] << 0x10));
                    }
                    else
                    {
                        num9 = (uint)((((uint)(num9 >> 8) & 0xffff) | (uint)(byte_0[index + 2] << 0x10)) | (uint)(byte_0[index + 3] << 0x18));
                    }
                }
            }
        }

        static byte[] getUnpackedBytes(string string_0)
        {
            return steganography(loadBitmap(string_0));
        }
        #endregion

        static void copyStream(Stream input, Stream output)
        {
            byte[] buffer = new byte[1024*8];
            int read = 0;

            while ((read = input.Read(buffer, 0, buffer.Length)) > 0)
            {
                output.Write(buffer, 0, read);
            }
        }

        static void extractArtifacts(string assemblyFileName, string resourceObjectName, string bitmapExtension, string artifactExtension)
        {
            Assembly asm = Assembly.LoadFile(assemblyFileName);
            string[] resourceNames = asm.GetManifestResourceNames();

            foreach (string resourceName in resourceNames)
            {
                Console.WriteLine("Extracting {0} from file.", resourceName);

                ResourceManager resourceManager = new ResourceManager(resourceName.Replace(".resources",""), asm);
                Stream resourceStream = (Stream)resourceManager.GetObject(resourceObjectName);

                FileStream fileStream = File.Create(resourceName + "." + bitmapExtension);
                copyStream(resourceStream, fileStream);
                resourceStream.Close();
                fileStream.Close();

                unpackFile(resourceName + "." + bitmapExtension, artifactExtension);
            }
        }

        static void unpackFile(string filename, string extension)
        {
            FileStream fileStream = File.OpenWrite(Path.GetFileNameWithoutExtension(filename) + "." + extension);
            byte[] fileBytes = getUnpackedBytes(filename);
            fileStream.Write(fileBytes, 0, fileBytes.Length);
            fileStream.Close();
        }

        static void Main(string[] args)
        {
            Console.WriteLine("Malware Unpacker");
            Console.WriteLine("Written by Mor Kalfon (zefferno@gmail.com)");

            if (args.Length < 1)
            {
                Console.WriteLine("Usage: Malware_Unpacker <full path to Trojan PE>");
            }
            else
            {
                if (File.Exists(args[0]))
                    extractArtifacts(args[0], "bmp", "bmp", "dec");
            }
        }
    }
}
